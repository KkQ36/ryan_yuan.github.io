[{"content":"Spring代理类创建流程梳理\n沿着上节的流程，详细的来看看 wrapIfNecessary() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { if (StringUtils.hasLength(beanName) \u0026amp;\u0026amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // 如果该类的 Advisor 不为空，创建代理类 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } 不生成代理类的情况 1 2 3 4 5 6 7 8 9 10 if (StringUtils.hasLength(beanName) \u0026amp;\u0026amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } 以下的四种情况将不会生成代理类：\nBeanName 不为空且在 targetSourcedBeans 集合中，直接返回原始 bean。 AdvisedBeans 缓存中存在 cacheKey 且值为 false，直接返回原始 bean。 Bean 属于基础设施类或满足跳过条件，将 cacheKey 标记为 false 并返回原始 bean。 没有与 Bean 匹配的 Advisor 获取适配类的 Advisors 1 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean(Class\u0026lt;?\u0026gt; beanClass, String beanName, @Nullable TargetSource targetSource)\n1 2 3 4 5 6 7 8 9 @Override @Nullable protected Object[] getAdvicesAndAdvisorsForBean(Class\u0026lt;?\u0026gt; beanClass, String beanName, @Nullable TargetSource targetSource) { List\u0026lt;Advisor\u0026gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) { return DO_NOT_PROXY; } return advisors.toArray(); } org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors(Class\u0026lt;?\u0026gt; beanClass, String beanName)\n1 2 3 4 5 6 7 8 9 protected List\u0026lt;Advisor\u0026gt; findEligibleAdvisors(Class\u0026lt;?\u0026gt; beanClass, String beanName) { List\u0026lt;Advisor\u0026gt; candidateAdvisors = findCandidateAdvisors(); List\u0026lt;Advisor\u0026gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; } 首先调用 findCandidateAdvisors 拿到所有的候选者 Advisor，再调用 findAdvisorsThatCanApply 选出适配该 Bean 的 Advisor。\n最终会调用到这个方法： org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply(List\u0026lt;Advisor\u0026gt; candidateAdvisors, Class\u0026lt;?\u0026gt; clazz)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static List\u0026lt;Advisor\u0026gt; findAdvisorsThatCanApply(List\u0026lt;Advisor\u0026gt; candidateAdvisors, Class\u0026lt;?\u0026gt; clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List\u0026lt;Advisor\u0026gt; eligibleAdvisors = new ArrayList\u0026lt;\u0026gt;(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor \u0026amp;\u0026amp; canApply(candidate, clazz)) { eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors; } 这个方法 findAdvisorsThatCanApply 用于过滤和筛选出可以应用于特定目标类 clazz 的增强器（Advisor），即 找出与该类匹配的 Advisor 列表。 首先遍历 candidateAdvisors 列表，筛选出所有的 IntroductionAdvisor。 对于每个 IntroductionAdvisor，调用 canApply(candidate, clazz) 方法判断它是否适用于目标类 clazz。 如果适用，就将它添加到 eligibleAdvisors 列表中。 再次遍历 candidateAdvisors 列表，排除 IntroductionAdvisor，只处理普通的 Advisor。 对于每个普通的 Advisor，调用 canApply(candidate, clazz, hasIntroductions) 方法检查它是否适用于目标类 clazz。 如果适用，将其添加到 eligibleAdvisors 列表中。\n创建代理类 1 2 3 4 5 6 7 if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } 如果 specificInterceptors 不为 null 就会去创建代理；\norg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy(Class\u0026lt;?\u0026gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 protected Object createProxy(Class\u0026lt;?\u0026gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (proxyFactory.isProxyTargetClass()) { // Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios) if (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) { // Must allow for introductions; can\u0026#39;t just set interfaces to the proxy\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : beanClass.getInterfaces()) { proxyFactory.addInterface(ifc); } } } else { // No proxyTargetClass flag enforced, let\u0026#39;s apply our default checks... if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // Use original ClassLoader if bean class not locally loaded in overriding class loader ClassLoader classLoader = getProxyClassLoader(); if (classLoader instanceof SmartClassLoader \u0026amp;\u0026amp; classLoader != beanClass.getClassLoader()) { classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader(); } return proxyFactory.getProxy(classLoader); } 该方法的返回值为：proxyFactory.getProxy(classLoader);，即调用 proxyFactory 的创建代理方法。\n代理工厂的初始化配置 整个方法其实就是对代理工厂的一个构建，在调用 proxyFactory.copyFrom(this); ，会将 Creator 的配置复制到代理工厂中： org.springframework.aop.framework.ProxyConfig#copyFrom(ProxyConfig other)\n1 2 3 4 5 6 7 8 public void copyFrom(ProxyConfig other) { Assert.notNull(other, \u0026#34;Other ProxyConfig object must not be null\u0026#34;); this.proxyTargetClass = other.proxyTargetClass; this.optimize = other.optimize; this.exposeProxy = other.exposeProxy; this.frozen = other.frozen; this.opaque = other.opaque; } proxyTargetSource：设置是否直接代理目标类，而不是仅代理特定的接口。默认值为 \u0026ldquo;false\u0026rdquo;。\n将其设置为 \u0026ldquo;true\u0026rdquo; 时，会强制对 TargetSource 所暴露的目标类进行代理。 如果目标类是一个接口，则会为该接口创建一个 JDK 代理。 如果目标类是一个普通的类，则会为该类创建一个 CGLIB 代理。 optimize：设置代理是否应执行“积极优化”。\n“积极优化”的具体含义因代理类型而异，但通常会涉及某种权衡，默认值为 \u0026ldquo;false\u0026rdquo;。 在 Spring 当前的代理选项中，此标志实际上会强制使用 CGLIB 代理，但不会执行任何类验证检查（如对 final 方法的检查等）。 opaque：设置由此配置创建的代理是否应该禁止被强制转换为 {@link Advised} 以查询代理状态。\n默认值为 \u0026ldquo;false\u0026rdquo;，这意味着任何 AOP 代理都可以被强制转换为 {@link Advised}。 frozen：决定代理的配置是否可以在运行时修改。\n默认情况下，配置是可变的，调用者可以通过将代理转换为 Advised 接口来修改通知链或其他配置。 当其设置为 true 的时候： 配置被锁定，不能再动态更改通知或切面配置。 增强系统的稳定性和性能，因为代理不需要支持动态修改。 根据是否代理目标类执行不同的操作 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (proxyFactory.isProxyTargetClass()) { // Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios) if (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) { // Must allow for introductions; can\u0026#39;t just set interfaces to the proxy\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : beanClass.getInterfaces()) { proxyFactory.addInterface(ifc); } } } else { // No proxyTargetClass flag enforced, let\u0026#39;s apply our default checks... if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } 上面我们提到，proxyTargetSource：设置是否直接代理目标类，而不是仅代理特定的接口。默认值为 \u0026ldquo;false\u0026rdquo;。 如果为 true 的话，对 JDK 代理类和 lambda 接口的实现类做一些特殊的处理，也就是保存接口的类型。 如果设置为 false 的话，执行默认的操作 首先检查 Bean 定义中是否明确制定了需要代理类而不是接口，如果是的话，将 proxyTargetSource 设置为 true。 反之调用 evaluateProxyInterfaces，评估 Bean 是否有实现的接口，我们说的如果 代理类没有实现接口，使用 CgLib 代理，反之，使用 JDK 代理正是这个方法的原因。\n全限定名：org.springframework.aop.framework.ProxyProcessorSupport#evaluateProxyInterfaces(Class\u0026lt;?\u0026gt; beanClass, ProxyFactory proxyFactory) 方法注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Check the interfaces on the given bean class and apply them to the {@link ProxyFactory}, * if appropriate. * \u0026lt;p\u0026gt;Calls {@link #isConfigurationCallbackInterface} and {@link #isInternalLanguageInterface} * to filter for reasonable proxy interfaces, falling back to a target-class proxy otherwise. * @param beanClass the class of the bean * @param proxyFactory the ProxyFactory for the bean */ /** * 检查给定 Bean 类上的接口，并在合适的情况下将这些接口应用到 {@link ProxyFactory}。 * * \u0026lt;p\u0026gt;会调用 {@link #isConfigurationCallbackInterface} 和 {@link #isInternalLanguageInterface} * 方法来过滤出合理的代理接口。如果没有找到合理的接口，则会退回到基于目标类（target-class）的代理。 * * @param beanClass Bean 的类 * @param proxyFactory 用于创建代理的 {@link ProxyFactory} */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 protected void evaluateProxyInterfaces(Class\u0026lt;?\u0026gt; beanClass, ProxyFactory proxyFactory) { Class\u0026lt;?\u0026gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader()); boolean hasReasonableProxyInterface = false; for (Class\u0026lt;?\u0026gt; ifc : targetInterfaces) { if (!isConfigurationCallbackInterface(ifc) \u0026amp;\u0026amp; !isInternalLanguageInterface(ifc) \u0026amp;\u0026amp; ifc.getMethods().length \u0026gt; 0) { hasReasonableProxyInterface = true; break; } } if (hasReasonableProxyInterface) { // Must allow for introductions; can\u0026#39;t just set interfaces to the target\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : targetInterfaces) { proxyFactory.addInterface(ifc); } } else { proxyFactory.setProxyTargetClass(true); } } 这个方法的作用是从目标类（beanClass）中提取需要代理的接口，并将它们添加到代理工厂（ProxyFactory）中，而如果没有找到合适的接口（即所有接口都被过滤掉），则会使用目标类进行代理（即启用 CGLIB 动态代理）。 使用 isConfigurationCallbackInterface 和 isInternalLanguageInterface 方法对接口进行筛选，确保只代理合理的接口。\n合理的接口通常是用户定义的接口，而非 Spring 内部使用的回调接口或与语言机制相关的内部接口。 这两个方法将这些接口排除在外： 1 2 3 4 5 6 7 8 9 protected boolean isConfigurationCallbackInterface(Class\u0026lt;?\u0026gt; ifc) { return (InitializingBean.class == ifc || DisposableBean.class == ifc || Closeable.class == ifc || AutoCloseable.class == ifc || ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class)); } protected boolean isInternalLanguageInterface(Class\u0026lt;?\u0026gt; ifc) { return (ifc.getName().equals(\u0026#34;groovy.lang.GroovyObject\u0026#34;) || ifc.getName().endsWith(\u0026#34;.cglib.proxy.Factory\u0026#34;) || ifc.getName().endsWith(\u0026#34;.bytebuddy.MockAccess\u0026#34;)); } 如果筛选后没有适合的接口，则会回退到基于目标类的代理方式（ 触发 CGLIB 动态代理 ）。\n填充代理工厂的其他属性 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // Use original ClassLoader if bean class not locally loaded in overriding class loader ClassLoader classLoader = getProxyClassLoader(); if (classLoader instanceof SmartClassLoader \u0026amp;\u0026amp; classLoader != beanClass.getClassLoader()) { classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader(); } 获取并构建一个 Advisor 列表，这个 specificInterceptors 是从 wrapIfNecessory中传递下来的，然后将这些 Advisor 添加到代理工厂。 Spring 使用 SmartClassLoader 检测目标类的类加载器和代理类的类加载器是否一致： 如果代理类的类加载器与目标类不一致，可能会导致类加载问题，因此 Spring 会尝试调整使用的类加载器。\n正式开始创建代理类 1 return proxyFactory.getProxy(classLoader); 其最终会调用到这个方法：\n全限定名：org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy(AdvisedSupport config) 接口定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Create an {@link AopProxy} for the given AOP configuration. * @param config the AOP configuration in the form of an * AdvisedSupport object * @return the corresponding AOP proxy * @throws AopConfigException if the configuration is invalid */ /** * 为给定的 AOP 配置创建一个 {@link AopProxy} 实例。 * * @param config 以 {@link AdvisedSupport} 对象形式表示的 AOP 配置信息 * @return 对应的 AOP 代理 * @throws AopConfigException 如果配置无效，则抛出此异常 / 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (!NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) { Class\u0026lt;?\u0026gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\u0026#34;TargetSource cannot determine target class: \u0026#34; + \u0026#34;Either an interface or a target is required for proxy creation.\u0026#34;); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } 传入的参数 AdvisedSupport 实际上就是我们上面构建的代理工厂，其实现了 AdvisedSupport 接口。 我们再来梳理一下这个配置中对一些值：\nisOptimize：默认 false，不进行智能代理优化 isProxyTargetClass：类或者Creator 指定需要代理的是目标类 或 类没有实现任何可用接口 时为 true，其他时候为 false 创建 CgLib 代理类 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 if (!NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) { Class\u0026lt;?\u0026gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\u0026#34;TargetSource cannot determine target class: \u0026#34; + \u0026#34;Either an interface or a target is required for proxy creation.\u0026#34;); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } !NativeDetector.inNativeImage() 用于检测当前环境能否使用 CgLib 代理，如果允许的话，下面的条件符合任意一条都会出发 CgLib 代理：\nisOptimize 智能代理优化 isProxyTargetClass 需要代理目标类 hasNoUserSuppliedProxyInterfaces，检测接口，如果发现用户没有提供任何自定义接口，Spring 可能会选择使用 CGLIB 代理。 还有一些特殊的情况，创建的是 JDK 代理类，这个放到下面去说。 创建 JDK 代理类 当下面的条件不符合\n1 !NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) 或者代理的类是一个接口、代理的类已经是一个 JDK 代理类、代理的类是一个 lambda 表达式的实现类\n1 targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass) 的时候，会创建 JDK 代理类。\n","date":"2024-11-17T00:00:00Z","image":"http://localhost:64097/p/spring-aop-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/image_hu15123054864233634991.png","permalink":"http://localhost:64097/p/spring-aop-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/","title":"Spring AOP 代理类创建方法解析"},{"content":"一句话来说，布隆过滤器是为了 解决集合中是否存在某一元素 这一问题。 这种需求非常常见，比如现有 500 万个电话号码，给你 1 万个电话号码，如何要快速准确的判断这些电话号码是否已经存在？\n什么是 Bitmap？ Bitmap（位图），顾名思义，是一种以二进制位（bit）来表示数据的特殊数据结构。 Bitmap案例 在编程中，我们往往需要记录某种状态，比如签到系统中的 用户签到状态，答题中的每道题作答状态，对于这种只有两种情况的状态，如果使用传统的数据结构，往往需要非常多的存储空间； 比如我们使用用户 id 来存储用户状态，比如使用 java 中的 int，每个 id 就需要 4 字节的存储空间；但是 Bitmap 通过将每一个状态（0或1）直接映射为一个位，就大大的节省了空间。 BitMap 有这些优点：\n空间效率很高，假设要存储一亿个用户的状态，使用 Bitmap 就只占用 12MB 的存储空间。 查询速度快，不管查询哪个数据，都只需要 O(1) 的时间复杂度。 简单易用，看了上面的介绍，大家应该也能实现一个简单的 Bitmap 了，在使用中，也只是简单的插入、查找、删除指令。 但是，Bitmap只能表示两种状态，不适合需要更多状态表示的场景。 此外，若数据稀疏（如仅有几个特定位被设置），则可能导致浪费存储空间，比如上面一亿用户的例子，可能只有几个人的状态被记录，那就会大量浪费空间。 布隆过滤器（Bloom Filter） 什么是布隆过滤器 「Wiki-Bloom filter」：https://en.wikipedia.org/wiki/Bloom_filter 如果我们有一个 10 万位的 Bitmap，此时突然需要我们记录一个序号为一亿的状态，我们要将 Bitmap 拓展到一亿位吗？ 这显然是不可取的，但是，可以通过 hash 函数将这个记录映射成 10 万以内的数据就解决了。 但只要有哈希，就有哈希碰撞，而只要有哈希碰撞就必然会引起误判，那有没有方法能够减弱这种误判呢？ 很简单，一个哈希不行，我可以用两个，两个不行我可以用三个。。。 布隆过滤器正是这样做的，通过 多个哈希函数，将数据映射到多个不同的索引位置，然后将这些索引位置通通置为 1，检查的时候，如果几个位置都为 1，那就说明元素肯定在库中。 但这样无法完全避免误判，比如有三个哈希函数，而一个不存在的元素映射的三个位置都被置为 1，这也是有可能的，但这种概率已经被降到了很小。 那，究竟有多小呢？\n布隆过滤器的误判率是多少？ 假设布隆过滤器的数组长度为 $m$，插入元素的个数为 $n$，使用哈希函数的个数为 $k$。\n对于一个特定的位，在插入一个元素时被置为 1 的概率为 $p = 1/m$。\n插入 $n$ 个元素后，这个位仍然为 0 的概率为 $(1 - p)^{kn}$。\n那么这个位为 1 的概率就是 $1-(1 - p)^{kn}$。\n当查询一个不在集合中的元素时，如果确定其存在的话，对于每个哈希函数对应的位都应该为 1，$P=(1-(1 - p)^{kn})^{k}$。\n将 $p = 1/m$ 代入上式，可得 $P=(1-(1-\\frac{1}{m})^{kn})^{k}$。\n对结果进行分析可以得知，数组长度越高，哈希函数越多的话，误判率越低，也非常符合我们的直觉。\n因为 $m$ 的值，也就是布隆过滤器的容量可以非常大，可以近似认为趋近于 $+\\infty$，此时上式可以视为 $P \\approx (1 - e^\\frac{-kn}{m})^k$\n绝大多数的时间，我们关注的都是误判率和插入元素的个数，即 $P$ 和 $n$，所以我们希望能够指定这两个个数，然后通过计算得出哈希函数的个数 k 和数组长度 m\n通过数学分析，我们可以发现，当 $k = \\frac{m}{n} \\ln 2$ 时，误判率 P 最小，将这个值代入上面的式子，简化指数项，可以得出 $P \\approx \\left( 1 - \\frac{1}{2} \\right)^{\\frac{m}{n} \\ln 2}$\n进而得出： $P \\approx \\left( \\frac{1}{2} \\right)^k$\n可以推导出 $P$ 和 $k$ 的关系，为：$k = -\\frac{\\ln P}{\\ln 2}$\n将这个式子代入 $k = \\frac{m}{n} \\ln 2$，可以得出 $m$ 和 $p$ 的关系，$m = \\frac{n\\ln P}{(\\ln 2)^2}$\n布隆过滤器的优缺点 首先，它是由 bit 数组来构成的，所占空间小。 和 Bitmap 相同，其插入和查询的时间复杂度均为 O(1)。 但是相较于 Bitmap，只要使用哈希，就不可避免的存在误判，所以布隆过滤器存在误判，但是通过合理的参数配置，误判率可以控制在一个可接受的范围内。 同时，布隆过滤器不允许删除元素，如果简单的将所有哈希函数计算出来的索引位置全部置为 1 的话，会引起大范围的误删。\nGuava 提供的布隆过滤器实现 「GitHub地址」：https://github.com/google/guava Guava，Google Java Core Libraries，是谷歌开发的 Java 核心库。 写一个简单的案例来延时一下 Guava 提供的布隆过滤器，测试环境为 jdk1.8；\n1 2 3 4 5 6 \u0026lt;!-- 引入 guava 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;30.1-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 创建布隆过滤器，依靠的是 com.google.common.hash.BloomFilter 类提供的 create() 方法，这个方法接受三个参数，分别是：\nFunnel：负责将对象转为一系列字节的工具接口，即指定布隆过滤器中要存放什么类型的对象。 expectedInsertions：期望插入的元素个数。 fpp：期望的误判率。 1 2 3 4 public static \u0026lt;T\u0026gt; BloomFilter\u0026lt;T\u0026gt; create( Funnel\u0026lt;? super T\u0026gt; funnel, int expectedInsertions, double fpp) { return create(funnel, (long) expectedInsertions, fpp); } 测试类，在主方法中，我们通过反射来查看一下 Guava 生成的布隆过滤器哈希函数个数和数组长度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 预计要插入多少数据 958,5058 100,0000 */ private static final int size = 1000000; /** * 期望的误判率 */ private static final double fpp = 0.01; /** * 布隆过滤器 */ private static final BloomFilter\u0026lt;Integer\u0026gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void main(String[] args) throws Exception { Class\u0026lt;BloomFilter\u0026gt; bloomFilterClass = BloomFilter.class; // 获取哈希函数个数 Field numHashFunctions = bloomFilterClass.getDeclaredField(\u0026#34;numHashFunctions\u0026#34;); numHashFunctions.setAccessible(true); System.out.println(\u0026#34;哈希函数个数 = \u0026#34; + numHashFunctions.get(bloomFilter)); // 获取数组长度 Method optimalNumOfBits = bloomFilterClass.getDeclaredMethod(\u0026#34;optimalNumOfBits\u0026#34;, long.class, double.class); optimalNumOfBits.setAccessible(true); System.out.println(\u0026#34;布隆过滤器大小 = \u0026#34; + optimalNumOfBits.invoke(bloomFilter, size, fpp)); // 插入10万样本数据 for (int i = 0; i \u0026lt; size; i++) { bloomFilter.put(i); } // 用另外十万没被插入的数据测试数据，测试误判率 int count = 0; for (int i = size; i \u0026lt; size + 100000; i++) { if (bloomFilter.mightContain(i)) { count++; } } System.out.println(\u0026#34;误判率:\u0026#34; + (double)count / 100000); } 输出结果为：\n1 2 3 哈希函数个数 = 7 布隆过滤器大小 = 9585058 误判率:0.00947 根据「布隆过滤器的误判率是多少？」部分的推导，相信大家对通过 期望插入元素的个数 以及 期望预判率 是计算 bit 数组长度和哈希函数个数的方法有所了解了，这里我们来尝试计算一下：\n首先计算位数组长度 $m$： 根据公式 $m = -\\frac{n * \\ln{p}}{(\\ln{2})^2}$，其中$n = size = 1000000$，$p = fpp = 0.01$。 先计算$\\ln{p}=\\ln{0.01}\\approx -4.60517$。 再计算$(\\ln{2})^2\\approx0.4804530139182014$。 则 $m = -\\frac{1000000 * (-4.60517)}{0.4804530139182014}\\approx9585059.539989209$。 接着计算哈希函数个数 $k$： 根据公式 $k = \\frac{m}{n} * \\ln{2}$，其中$m\\approx9585059.539989209$，$n = 1000000$。 先计算 $\\ln{2}\\approx0.6931471805599453$。 则 $k=\\frac{9585059.539989209}{1000000} * 0.6931471805599453\\approx6.643859708244697$，取整为 $7$。 最终计算得出，位数组长度约为 $9585059.539989209$，哈希函数个数为 $7$，和测试结果完全吻合。 布谷鸟过滤器：Cuckoo Filter 什么是布谷鸟过滤器？ 「Cuckoo Filter: Practically Better Than Bloom」：https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf 「GitHub 地址」：https://github.com/efficient/cuckoofilter 「Wiki-Cuckoo filter」：https://en.wikipedia.org/wiki/Cuckoo_filter 下面的部分来自对 GitHub 梗概部分的简单翻译： 布谷鸟过滤器（Cuckoo filter）是一种用于近似集合成员查询的布隆过滤器替代方案。 布隆过滤器是众所周知的节省空间的数据结构，适合用于回答“元素 x 是否在集合中？”这样的查询。但布隆过滤器不支持删除操作。为了支持删除功能，布隆过滤器的一些变体（如计数布隆过滤器）通常需要更多的存储空间。 布谷鸟过滤器提供了灵活的动态添加和删除元素的能力。布谷鸟过滤器基于布谷鸟哈希（因此命名为布谷鸟过滤器）。它本质上是一个布谷鸟哈希表，存储每个密钥的指纹。 布谷鸟哈希表可以非常紧凑，因此 cuckoo 过滤器可以比传统的布隆过滤器使用更少的空间，且适用于需要低误报率 （\u0026lt; 3%） 的应用程序。 可以看出，布谷鸟在布隆过滤器的基础上，提供了 删除 的能力，而且还优化了空间和效率。\n布谷鸟过滤器是如何支持删除的？ 如上图所示，布谷鸟过滤器由三部分组成：哈希表、存储在哈希表中的指纹和两个不独立的哈希函数。 既然要删除元素，将不可避免的要去存储这个元素或者说存储某个标识，在布谷鸟过滤器中，这个元素的标识被称为指纹（fingerprint），当删除的时候，只需要删除这个元素的指纹就可以了。\n布谷鸟过滤器的实现原理 在 GitHub 官网中提到，布谷鸟过滤器对外提供了这些 API：\n1 2 3 4 5 Add(item): 将元素插入过滤器。 Contain(item): 如果元素已在过滤器中，则返回。请注意，和布隆过滤器一样，此方法可能会误报。 Delete(item): 从过滤器中删除给定的项目。请注意，要使用此方法，必须确保此项目在过滤器中;否则，可能会误删。 Size(): 返回过滤器中当前项目的总数。 SizeInBytes(): 返回过滤器大小，单位为字节。 插入（Add） 采用伪代码的形式，插入的流程是这样的：\n1 2 3 4 5 6 7 8 9 fp = getFingerprint(x); p1 = hash1(x); insert(p1); if (失败) { // hash2 保证，hash2(p2, fp) == p1 p2 = hash2(p1, fp); insert(p2); if (再次失败) 执行驱逐代码 } 与布隆过滤器使用 bit 数组不同的是，布谷鸟过滤器使用的是哈希数组，某一个位置（Bucket）可以存储多个指纹，只有当这个 Bucket 完全被填满了之后，再去尝试其他的方法。 当一个元素x要插入到布谷鸟过滤器时，布谷鸟过滤器会先使用fingerprint函数计算出指纹fp，接着用 hash1 算法对计算式第一个桶位置 p1，然后尝试将指纹插入到 p1 的位置； 如果插入失败的话，再次通过 hash2 函数，传入 p1 和 fp，然后尝试将指纹插入到 p2 位置。 但如果 p2 位置也满了的话，就会触发布谷鸟过滤器的驱逐（kickout）机制，它会将这个桶中随机的一个元素踢出去，然后直接鸠占鹊巢； 被踢出去的这个元素再次去尝试上面的步骤，继续寻找位置、尝试插入、驱逐、寻找位置。。。 但这个过程不是无穷无尽的，当尝试的次数达到某个上限的时候，布谷鸟过滤器就会认为自己已满。 口说无凭，我们直接来看一下布谷鸟过滤器的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename ItemType, size_t bits_per_item, template \u0026lt;size_t\u0026gt; class TableType, typename HashFamily\u0026gt; Status CuckooFilter\u0026lt;ItemType, bits_per_item, TableType, HashFamily\u0026gt;::Add( const ItemType \u0026amp;item) { size_t i; // p1 uint32_t tag; // 指纹 if (victim_.used) { // 检测是否还有空间 return NotEnoughSpace; } GenerateIndexTagHash(item, \u0026amp;i, \u0026amp;tag); return AddImpl(i, tag); } // 计算索引 1 和 指纹 tag inline void GenerateIndexTagHash(const ItemType\u0026amp; item, size_t* index, uint32_t* tag) const { const uint64_t hash = hasher_(item); *index = IndexHash(hash \u0026gt;\u0026gt; 32); *tag = TagHash(hash); } 首先通过 victim_.used 判断是否为满，为什么可以判断放到后面去讲解。 然后通过 GenerateIndexTagHash 生成下标 1 和指纹。 调用 AddImpl 将元素添加到哈希表中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template \u0026lt;typename ItemType, size_t bits_per_item, template \u0026lt;size_t\u0026gt; class TableType, typename HashFamily\u0026gt; Status CuckooFilter\u0026lt;ItemType, bits_per_item, TableType, HashFamily\u0026gt;::AddImpl( const size_t i, const uint32_t tag) { size_t curindex = i; // 当前插入元素的下标 uint32_t curtag = tag; // 当前插入元素的指纹 uint32_t oldtag; // 暂存被驱逐的元素指纹 for (uint32_t count = 0; count \u0026lt; kMaxCuckooCount; count++) { bool kickout = count \u0026gt; 0; // 驱逐开始的时机：计算替代索引之后 oldtag = 0; if (table_-\u0026gt;InsertTagToBucket(curindex, curtag, kickout, oldtag)) { // 插入成功的话，计数 num_items_++; return Ok; } // 如果没有插入，说明需要驱逐，将 curtag 设置为被驱逐的元素 if (kickout) { curtag = oldtag; } // 计算替代索引 curindex = AltIndex(curindex, curtag); } // 如果最终还没有插入成功，视为满了，做些善后工作 victim_.index = curindex; victim_.tag = curtag; victim_.used = true; return Ok; } 上面列出的就是插入元素的具体实现\n如果第一次就插入成功，也就是 table_-\u0026gt;InsertTagToBucket(curindex, curtag, kickout, oldtag) 语句执行成功，直接返回 OK。 如果第一次没有插入成功，接下来的插入操作都将进入驱逐模式，即如果没有空位置，就将原位置的元素直接踢出，InsertTagToBucket(curindex, curtag, kickout, oldtag) 将会将 oldtag 设置为踢出的元素，然后继续执行插入操作。 如果到最后还是没有成功，可以视为过滤器已经满了，此时 victim_.used = true;，这也是为什么上面可以通过 victim_.used 来判断过滤器是否满的原因。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline bool InsertTagToBucket(const size_t i, const uint32_t tag, const bool kickout, uint32_t \u0026amp;oldtag) { for (size_t j = 0; j \u0026lt; kTagsPerBucket; j++) { if (ReadTag(i, j) == 0) { WriteTag(i, j, tag); return true; } } if (kickout) { size_t r = rand() % kTagsPerBucket; oldtag = ReadTag(i, r); WriteTag(i, r, tag); } return false; } 插入方法：InsertTagToBucket， 先尝试在索引位置插入元素，如果插入失败，且当前不是驱逐模式，直接返回； 如果当前是驱逐模式，将随机一个元素存储在 oldtag 中，然后将元素插入到那个位置\n1 2 3 4 5 inline size_t AltIndex(const size_t index, const uint32_t tag) const { // NOTE(binfan): originally we use: // index ^ HashUtil::BobHash((const void*) (\u0026amp;tag), 4)) \u0026amp; table_-\u0026gt;INDEXMASK; // now doing a quick-n-dirty way: // 0x5bd1e995 is the hash constant from MurmurHash2 return IndexHash((uint32_t)(index ^ (tag * 0x5bd1e995))); } AltIndex 函数根据计算出的主索引 index 和标签 tag 计算一个替代索引。它通过对主索引 index 和标签 tag 乘以一个常数 0x5bd1e995 后进行异或（^）运算，再通过 IndexHash 计算出替代位置。 相比于之前的异或操作（也是现在网上大部分的解释），这种做法在实现简单的同时依然具有良好的分布特性，确保元素能在较小的表中分布均匀，同时这个操作是可逆的，即通过 p2 也能得到 p2。\n查询是否存在（Contain） 看懂了 Add 方法，后面就非常容易理解了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template \u0026lt;typename ItemType, size_t bits_per_item, template \u0026lt;size_t\u0026gt; class TableType, typename HashFamily\u0026gt; Status CuckooFilter\u0026lt;ItemType, bits_per_item, TableType, HashFamily\u0026gt;::Contain( const ItemType \u0026amp;key) const { bool found = false; size_t i1, i2; uint32_t tag; GenerateIndexTagHash(key, \u0026amp;i1, \u0026amp;tag); i2 = AltIndex(i1, tag); assert(i1 == AltIndex(i2, tag)); found = victim_.used \u0026amp;\u0026amp; (tag == victim_.tag) \u0026amp;\u0026amp; (i1 == victim_.index || i2 == victim_.index); if (found || table_-\u0026gt;FindTagInBuckets(i1, i2, tag)) { return Ok; } else { return NotFound; } } 上面的方法就是计算 i1 和 i2，然后去这两个位置寻找，如果存在的话，返回 true。 found = victim_.used \u0026amp;\u0026amp; (tag == victim_.tag) \u0026amp;\u0026amp; (i1 == victim_.index || i2 == victim_.index); 是为了在过滤器满了之后插入的那个元素可以被检索到。\n删除操作（Delete） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 template \u0026lt;typename ItemType, size_t bits_per_item, template \u0026lt;size_t\u0026gt; class TableType, typename HashFamily\u0026gt; Status CuckooFilter\u0026lt;ItemType, bits_per_item, TableType, HashFamily\u0026gt;::Delete( const ItemType \u0026amp;key) { // 生成索引 size_t i1, i2; uint32_t tag; GenerateIndexTagHash(key, \u0026amp;i1, \u0026amp;tag); i2 = AltIndex(i1, tag); // 尝试删除元素，删除成功的话，跳到 TryEliminateVictim 去尝试清楚受害者元素 if (table_-\u0026gt;DeleteTagFromBucket(i1, tag)) { num_items_--; goto TryEliminateVictim; } else if (table_-\u0026gt;DeleteTagFromBucket(i2, tag)) { num_items_--; goto TryEliminateVictim; } else if (victim_.used \u0026amp;\u0026amp; tag == victim_.tag \u0026amp;\u0026amp; (i1 == victim_.index || i2 == victim_.index)) { // num_items_--; victim_.used = false; return Ok; } else { return NotFound; } TryEliminateVictim: // 清除受害者 if (victim_.used) { victim_.used = false; size_t i = victim_.index; uint32_t tag = victim_.tag; AddImpl(i, tag); } return Ok; } 还是先生成两个索引位置，首先在索引 i1 的桶中尝试删除 tag，如果成功找到并删除，计数 num_items_ 减 1，并跳到 TryEliminateVictim。 如果 i1 删除失败，则在 i2 的桶中尝试删除 tag。若找到并删除，num_items_ 减 1，并跳到 TryEliminateVictim。 TryEliminateVictim 方法会尝试清除一个受害者，如果存在一个受害者项也就是满了之后插入的第一个元素（victim_），它会尝试重新添加该受害者项到表中。然后设置 victim_.used 为 false，然后调用 AddImpl(i, tag) 将 victim_ 项放入其索引 i 位置如果上述两步均未成功，检查是否存在一个待处理的受害者项（victim_），如果该受害者项匹配 tag 并且其索引为 i1 或 i2，则清除 victim_ 并返回 Ok，表示删除成功。\n布谷鸟过滤器能够替代布隆过滤器吗？ 布谷鸟过滤器也有自己的缺陷，且目前还无法替代布隆过滤器：\n布谷鸟过滤器要求存储空间必须为 2 的幂次，其容量计算的方式为：upperpower2(std::max\u0026lt;uint64_t\u0026gt;(1, max_num_keys / assoc))， upperpower2函数用于计算大于或等于给定值 x 的最小的2的幂。 随着元素个数的增加，发生 kickout 的概率也会增加，导致元素插入时间变慢。 对于同一个元素，布谷鸟过滤器最多存储 $2 * k$ 次，k 为桶的容量，如果超过这个数，插入必将会失败。 布谷鸟过滤器删除的是指纹副本，而无法完全确定这个指纹是属于需要删除的元素的。 与其他过滤器的比较 ![[布谷鸟过滤器与其他过滤器在空间效率上的比较.png|800]] 上图出自「Cuckoo Filter: Practically Better Than Bloom」，由此可知，布谷鸟过滤器在维护低误判率需要的空间成本上比布隆过滤器更低。\n","date":"2024-11-17T00:00:00Z","image":"http://localhost:64097/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3/image_hu16033865038594683048.png","permalink":"http://localhost:64097/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3/","title":"布隆过滤器详解"},{"content":"这部分我们来具体的看一下 Spring AOP 实现中，代理类究竟是什么时候被构建的。\n案例准备 maven pom 文件 spring.version：5.3.22 java.version：1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- Spring核心库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring IoC容器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring上下文支持，提供了BeanFactory的扩展 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Service 接口与实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public interface IUserService { void queryUserName(String uId); void queryUserId(String name); } public class UserService implements IUserService { @Override public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } @Override public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 通知类 1 2 3 4 5 6 7 8 9 10 11 public class LogAdvices { public void before() { System.out.println(\u0026#34;before\u0026#34;); } public void after() { System.out.println(\u0026#34;after\u0026#34;); } } 为了演示方便，本文所有的 Bean 都会通过配置文件来配置。 Main 方法 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); IUserService service = applicationContext.getBean(\u0026#34;userService\u0026#34;, IUserService.class); System.out.println(service.getClass()); service.queryUserName(\u0026#34;10001\u0026#34;); } } spring xml 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.ryan.aop_test.service.impl.UserService\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;logAspect\u0026#34; class=\u0026#34;com.ryan.aop_test.LogAdvices\u0026#34; /\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point1\u0026#34; expression=\u0026#34;execution(* com.ryan.aop_test.service.*.*(..))\u0026#34; /\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;logAspect\u0026#34;\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34; /\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 关于 spring 通过 xml 配置 aop 的具体内容可以参照官网：\n文档地址：https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-schema 需要注意，这种方式使用的是 Spring 的自动代理机制，如果有类似 BeanNameAutoProxyCreator 或类似的类使用了显示的代理，会导致其中的某一项失效。 建议的使用方式是仅使用\u0026lt;aop:config\u0026gt;样式或仅使用AutoProxyCreator样式，并且切勿混合使用它们。\n执行结果 先来看一下上面的 Main 方法执行后的效果：\n1 2 3 4 class com.sun.proxy.$Proxy3 before 查询用户名称为：ryan after 可以看到，我们获取到的类是一个代理类，并且代理方法已经执行成功了。\n源码分析 XML 解析 当执行下面这条语句之后：\n1 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); 会执行 ClassPathXmlApplicationContext 的 refresh 方法： org.springframework.context.support.AbstractApplicationContext#refresh()\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\u0026#34;spring.context.refresh\u0026#34;); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // ...... } 其中 obtainFreshBeanFactory 会执行 Bean 工厂的初始化，其中最重要的部分就是将 XML 配置文件中的 Bean 定义（Bean Definition）加载到 Bean 工厂中。\n1 2 3 4 5 6 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory() =\u0026gt; org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 上面的是从 `refresh()` 方法到具体加载 Bean Definition 方法的调用链路。 org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context\u0026#39;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader); } 具体解析 XML 和加载 Bean Definition 的方法 关于具体是如何解析 XML 的，这里就不细看了，我们直接看一下从我们的 XML 配置文件中可以解析到什么 配置文件：[[🗺️【spring-aop】Spring 代理类创建流程梳理#spring xml 配置文件]]\n1 2 3 4 5 6 7 beanDefinitionNames = {ArrayList@1626} size = 6 0 = \u0026#34;userService\u0026#34; 1 = \u0026#34;logAspect\u0026#34; 2 = \u0026#34;org.springframework.aop.config.internalAutoProxyCreator\u0026#34; 3 = \u0026#34;point1\u0026#34; 4 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#0\u0026#34; 5 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#1\u0026#34; 除了这些 infrastructure，上面还有一个 名称 为org.springframework.aop.config.internalAutoProxyCreator 的 Bean。 这个 Bean 的实际类型是：org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator，它是一个 InstantiationAwareBeanPostProcessor，AbstractAdvisorAutoProxyCreator 类实现了下面这个方法：\n1 2 3 default Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) throws BeansException { return null; } 这个方法会在 Bean 的实例化前被调用，可以用于修改和创建 Bean 对象。 除此之外，AbstractAdvisorAutoProxyCreator 还实现了 BeanPostProcessor 接口的 postProcessAfterInitialization，在 Bean 对象执行完初始化方法后，会调用这个方法检测是否需要将其转化为代理对象。 AbstractAdvisorAutoProxyCreator 是 AOP 代理中非常关键的一个类，整个创建 AOP 代理的核心流程就是其执行的这两个方法。\n加载 Creator 上面提到，org.springframework.aop.config.internalAutoProxyCreator 是一个 BeanPostProcessor，那它具体创建并注册的位置就是： org.springframework.context.support#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) 调用这个方法的位置还是 ApplicationContext 的 refresh() 方法，具体的调用链路为：\n1 2 3 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) 具体就是将 BeanPostProcessor 加载到工厂中，方便后续的调用。 具体存放 BeanPostProcessor 的位置为：org.springframework.beans.factory.support.AbstractBeanFactory 的 beanPostProcessors 属性。\n加载 Advisors 在「XML 解析」部分，我们看到了 spring 为我们将 xml 中定义的 \u0026lt;acp:config /\u0026gt; 解析为具体的 Bean 定义。 并且在「加载 Creator」部分，spring 已经将 AOP 创建者类注册成了一个 InstantiationAwareBeanPostProcessor。 在将单例 Bean（原型 Bean 也可以被代理，本文只关注单例 Bean 的代理过程）加载代理之前，肯定是要将上面 \u0026lt;acp:config /\u0026gt; 中配置的 Bean 构建出来的。 而如果按照我们在 xml 中配置的方式，显然先构建的 Bean 将会是 userService。 所以在所有的 Bean 实例化之前，需要确保这些构建 AOP 的 infrastructure 被提前构建好，这就是 AbstractAdvisorAutoProxyCreator 在 Bean 初始化之前执行的逻辑。 我们依然从 refresh() 方法开始：\n1 2 3 4 5 6 7 8 9 10 11 12 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons() 在预先实例化单例 Bean 的方法中，会对所有的 Bean 执行 `getBean()` 方法，`getBean()` 方法如果发现 Bean 没有被加载或者为原型 Bean，将会触发 Bean 的加载。 =\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.getBean(String name) =\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(String name, @Nullable Class\u0026lt;T\u0026gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) Bean 的 `createBean()` 方法实际上是延迟调用的，后续在 spring 三级缓存中会具体讲解，这里我们可以视为直接调用了 `createBean() 方法 =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) 这里就是具体执行 BeanPostProcessor 的位置：\n1 2 3 4 5 6 7 8 9 protected Object applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null; } 在这里会遍历所有的 BeanPostProcessor，然后调用其 postProcessBeforeInstantiation，上面的 AbstractAdvisorAutoProxyCreator 的该方法就是在这里调用的。\norg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // 如果有自定义的 TargetSource，则在这里创建代理对象 TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { if (StringUtils.hasLength(beanName)) { this.targetSourcedBeans.add(beanName); } Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } return null; } 在上面的 shouldSkip() 方法中，会尝试去获取所有的 Advisor，未创建的话，则会去尝试创建这些 Advisor。\n1 2 3 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#shouldSkip(Class\u0026lt;?\u0026gt; beanClass, String beanName) =\u0026gt; org.springframework.aop.framework.autoproxy.AspectJAwareAdvisorAutoProxyCreator#findCandidateAdvisors() =\u0026gt; org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public List\u0026lt;Advisor\u0026gt; findAdvisorBeans() { // 获取 advisorNames String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } if (advisorNames.length == 0) { return new ArrayList\u0026lt;\u0026gt;(); } // 不断从 Factory 中去 getBean() List\u0026lt;Advisor\u0026gt; advisors = new ArrayList\u0026lt;\u0026gt;(); for (String name : advisorNames) { if (isEligibleBean(name)) { if (this.beanFactory.isCurrentlyInCreation(name)) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Skipping currently created advisor \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } } else { try { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } catch (BeanCreationException ex) { // ...... } } } } return advisors; } 最终在 BeanFactoryAdvisorRetrievalHelper 中，获取到了所有的 advisor。 对于没有指定 targetSource 的 Bean，AbstractAdvisorAutoProxyCreator 不会对其进行任何操作，而是只进行了 Advisor 的初始化。\n创建代理类 从 createBean() 方法开始，我们再来看一下代理类具体是怎么创建的：\n1 2 3 4 5 6 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) doCreateBean 就是实际上创建 Bean 的方法，当 Bean 被实例化完成之后，会执行 Bean 的初始化，当其初始化结束之后，就会执行 AbstractAdvisorAutoProxyCreator 实现的另一个重要方法，代理类的构建就是在这里完成的。 =\u0026gt; `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) =\u0026gt; `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName) 这个方法会执行所有的 BeanPostProcessor 的 postProcessAfterInitialization() 方法，AbstractAdvisorAutoProxyCreator 中的这个方法就是在这里执行的：\n1 2 3 4 5 6 7 8 9 10 @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (this.earlyProxyReferences.remove(cacheKey) != bean) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } ","date":"2024-11-15T00:00:00Z","image":"http://localhost:64097/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image_hu6850457685914377867.png","permalink":"http://localhost:64097/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/","title":"Spring 代理类创建流程梳理"},{"content":"前言 AOP：意为面向切面编程，通过预编译的方式和运行期间动态代理实现程序功能功能的统一维护。\n既然要实现 AOP 就一定离不开代理，Spring 中使用两种代理方式：CgLib 动态代理和 AOP 动态代理，还通过引入 AspectJ 来简化切面编程。\nAOP 执行过程可以简单理解为对 切点(JointPoint) 执行 通知(Advice) 中定义的逻辑，这就引出两个核心的问题需要解决：\n通知在何处执行？ 如何判断当前执行的方法是否符合切点逻辑？ 动态代理可以让我们自由的在方法执行前后插入自己的逻辑，这就解决了通知在何处执行的问题；\n但是动态代理（无论是 JDKProxy 的 invoke() 还是 CgLib 的 interctpt()）都是在被代理的类中的任何方法执行前执行的，所以判断该方法是否需要执行切点逻辑需要我们来实现。\n图例\n上面展示的是一个代理类处理 AOP 的逻辑，其中 MethodInterceptor 是方法执行前的一个拦截器；MethodMatcher 是一个方法匹配器，通过它来判断接下来要执行的方法之前是否需要处理代理逻辑； 如果被代理的方法符合切点表达式，则按照顺序执行定义的代理逻辑，这样一个简单的 AOP 逻辑就打通了。\n案例 案例准备 1 2 3 4 5 6 7 8 9 10 11 public class UserService implements IUserService { public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 被代理的 UserService 类。\n定义方法匹配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MethodMatcherImpl implements MethodMatcher { private final PointcutExpression pointcutExpression; MethodMatcherImpl(String expression) { PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution(); pointcutExpression = parser.parsePointcutExpression(expression); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass) { return pointcutExpression.matchesMethodExecution(method).alwaysMatches(); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass, Object[] objects) { return false; } @Override public boolean isRuntime() { return false; } } 这是一个方法匹配类，用于检测输入的方法是否符合切点表达式 定义方法拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CgLibInterceptor implements MethodInterceptor { private final Object target; private final MethodMatcher methodMatcher; CgLibInterceptor(Object target, String expression) { this.methodMatcher = new MethodMatcherImpl(expression); this.target = target; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { if (methodMatcher.matches(method, target.getClass())) { System.out.println(\u0026#34;cglib代理：执行切面逻辑\u0026#34;); return methodProxy.invoke(target, objects); } return methodProxy.invoke(target, objects); } } 提供给 CgLib 的 CallBack 类，根据方法是否匹配切点表达式来决定是否执行切面逻辑。 创建代理类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ProxyTest { final static UserService target = new UserService(); public static void main(String[] args) throws IOException, InterruptedException { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserService.class); enhancer.setCallback(new CgLibInterceptor(target, \u0026#34;execution(* com.ryan.aop_test.service.impl.UserService.queryUserName(..))\u0026#34;)); UserService proxyService = (UserService) enhancer.create(); proxyService.queryUserName(\u0026#34;10001\u0026#34;); System.out.println(\u0026#34;======\u0026#34;); proxyService.queryUserId(\u0026#34;ryan\u0026#34;); } } 测试类，这里使用切点表达式匹配 UserService 类中的 queryUserName 方法 输出案例中，也只有这个方法会被代理 输出结果\n1 2 3 4 cglib代理 查询用户名称为：ryan ====== 查询用户ID为：10001 ","date":"2024-11-12T00:00:00Z","image":"http://localhost:64097/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:64097/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/","title":"实现一个简单的 AOP 切面"},{"content":"什么是 AOP？ AOP（Aspect Oriented Programming），意为面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\nAOP是OOP的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n举一个简单的例子，如果我们想要在每次调用一个类中的方法之前输出一个日志,那如果我们要在这些方法之前加一个鉴权呢？同样，按照前面的方式，无非就是多 copy 一次嘛\n就这样，通过多重 copy 的方式，最终完成了这个业务，而这也就代表着，每次扩展新的方法，你都要去进行 n 次复制粘贴；每次要更改鉴权或者日志的逻辑，你都要去进行 n 次复制粘贴；每次。。。。。。\n听起来都让人非常头大，但如果我们将逻辑改成这样呢？\n现在来看看 AOP 能实现怎样的效果：\n这样，我们虽然每次都不用去复制代码了，但还是需要在我们需要的位置去调用这个接口，而调用这个代码的位置其实就是 切面。我们用具体的代码来看一下，下面实现了一个统一的接口 BeforeAdvice，然后在每个方法之前去调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface BeforeAdvice { void before(); } public class LoggingBeforeAdvice implements BeforeAdvice { @Override public void before() { System.out.println(\u0026#34;方法调用之前的日志\u0026#34;); } } public class MyService { private BeforeAdvice beforeAdvice = new LoggingBeforeAdvice(); public void myMethodA() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethod1A\u0026#34;); } public void myMethodB() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethodB\u0026#34;); } } AOP 核心概念 连接点（Join Point）：连接点是程序执行中的一个点，这个点可以是方法调用、方法执行、异常抛出等。在 Spring AOP 中，连接点主要是指方法的调用或执行。连接点是通知的实际应用点。\n切点（PointCut）：由于连接点可能很多（比如一个类中的所有方法），想要把所有连接点罗列出现显然有些困难；切点是一个定义，决定了 在哪些连接点上应用切面逻辑。 切点通过切点表达式（例如：execution(* com.example.service..(..))）来指定匹配的方法和类。切点表达式用于筛选连接点，使得通知只在特定的连接点上执行。\n通知（Advice）：通知是在切点处执行的代码。通知定义了具体的横切逻辑，决定了在方法执行的什么阶段（之前、之后、环绕等）插入横切逻辑。通知有五种类型，我们会在下一部分进行详细的了解；通知就是在 何时 执行 怎样 的逻辑。\n切面（Aspect）：切面是 AOP 的核心模块，它封装了跨越多个类的关注点，例如日志记录、事务管理或安全控制。切面通过通知（Advice）和切点（Pointcut）来定义在何时、何地应用这些关注点；可以将切面看作是切点（Pointcut）和通知（Advice）的组合。 切面定义了在何处（切点）以及何时（通知）应用横切逻辑。\n五种通知类型 前置通知（Before Advice） 在目标方法执行之前执行的通知。可以用来执行日志记录、安全检查等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @Before(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void beforeAdvice() { System.out.println(\u0026#34;前置通知：方法调用之前执行\u0026#34;); } } 后置通知（After Advice） 在目标方法执行之后执行的通知，无论方法是成功返回还是抛出异常。常用于清理资源等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @After(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void afterAdvice() { System.out.println(\u0026#34;后置通知：方法调用之后执行\u0026#34;); } } 返回后通知（After Returning Advice） 在目标方法成功返回结果之后执行的通知。可以用来记录返回值或对返回值进行处理。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterReturning(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, returning = \u0026#34;result\u0026#34;) public void afterReturningAdvice(Object result) { System.out.println(\u0026#34;返回后通知：方法返回值为 \u0026#34; + result); } } 抛出异常后通知（After Throwing Advice） 在目标方法抛出异常后执行的通知。可以用来记录异常信息或执行异常处理逻辑。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, throwing = \u0026#34;exception\u0026#34;) public void afterThrowingAdvice(Exception exception) { System.out.println(\u0026#34;抛出异常后通知：异常为 \u0026#34; + exception.getMessage()); } } 环绕通知（Around Advice） 环绕通知在目标方法执行的前后都执行，可以完全控制目标方法的执行，包括决定是否执行目标方法，以及在目标方法执行前后添加自定义逻辑。环绕通知最为强大和灵活。\n1 2 3 4 5 6 7 8 9 10 11 @Aspect @Component public class LoggingAspect { @Around(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;环绕通知：方法调用之前\u0026#34;); Object result = joinPoint.proceed(); // 执行目标方法 System.out.println(\u0026#34;环绕通知：方法调用之后\u0026#34;); return result; } } 这五种通知类型的执行顺序是这样的： 前置通知（Before Advice） 环绕通知（Around Advice）的前半部分 目标方法执行 环绕通知（Around Advice）的后半部分 返回后通知（After Returning Advice）（如果目标方法成功返回） 抛出异常后通知（After Throwing Advice）（如果目标方法抛出异常） 后置通知（After Advice）\n","date":"2024-10-09T00:00:00Z","image":"http://localhost:64097/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:64097/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","title":"AOP 核心概念"}]