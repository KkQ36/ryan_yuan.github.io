[{"content":"这部分我们来具体的看一下 Spring AOP 实现中，代理类究竟是什么时候被构建的。\n案例准备 maven pom 文件 spring.version：5.3.22 java.version：1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- Spring核心库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring IoC容器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring上下文支持，提供了BeanFactory的扩展 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Service 接口与实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public interface IUserService { void queryUserName(String uId); void queryUserId(String name); } public class UserService implements IUserService { @Override public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } @Override public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 通知类 1 2 3 4 5 6 7 8 9 10 11 public class LogAdvices { public void before() { System.out.println(\u0026#34;before\u0026#34;); } public void after() { System.out.println(\u0026#34;after\u0026#34;); } } 为了演示方便，本文所有的 Bean 都会通过配置文件来配置。 Main 方法 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); IUserService service = applicationContext.getBean(\u0026#34;userService\u0026#34;, IUserService.class); System.out.println(service.getClass()); service.queryUserName(\u0026#34;10001\u0026#34;); } } spring xml 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.ryan.aop_test.service.impl.UserService\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;logAspect\u0026#34; class=\u0026#34;com.ryan.aop_test.LogAdvices\u0026#34; /\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point1\u0026#34; expression=\u0026#34;execution(* com.ryan.aop_test.service.*.*(..))\u0026#34; /\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;logAspect\u0026#34;\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34; /\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 关于 spring 通过 xml 配置 aop 的具体内容可以参照官网：\n文档地址：https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-schema 需要注意，这种方式使用的是 Spring 的自动代理机制，如果有类似 BeanNameAutoProxyCreator 或类似的类使用了显示的代理，会导致其中的某一项失效。 建议的使用方式是仅使用\u0026lt;aop:config\u0026gt;样式或仅使用AutoProxyCreator样式，并且切勿混合使用它们。\n执行结果 先来看一下上面的 Main 方法执行后的效果：\n1 2 3 4 class com.sun.proxy.$Proxy3 before 查询用户名称为：ryan after 可以看到，我们获取到的类是一个代理类，并且代理方法已经执行成功了。\n源码分析 XML 解析 当执行下面这条语句之后：\n1 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); 会执行 ClassPathXmlApplicationContext 的 refresh 方法： org.springframework.context.support.AbstractApplicationContext#refresh()\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\u0026#34;spring.context.refresh\u0026#34;); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // ...... } 其中 obtainFreshBeanFactory 会执行 Bean 工厂的初始化，其中最重要的部分就是将 XML 配置文件中的 Bean 定义（Bean Definition）加载到 Bean 工厂中。\norg.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory() =\u0026gt; org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 上面的是从 refresh() 方法到具体加载 Bean Definition 方法的调用链路。\norg.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context\u0026#39;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader); } 具体解析 XML 和加载 Bean Definition 的方法 关于具体是如何解析 XML 的，这里就不细看了，我们直接看一下从我们的 XML 配置文件中可以解析到什么 配置文件：[[🗺️【spring-aop】Spring 代理类创建流程梳理#spring xml 配置文件]]\n1 2 3 4 5 6 7 beanDefinitionNames = {ArrayList@1626} size = 6 0 = \u0026#34;userService\u0026#34; 1 = \u0026#34;logAspect\u0026#34; 2 = \u0026#34;org.springframework.aop.config.internalAutoProxyCreator\u0026#34; 3 = \u0026#34;point1\u0026#34; 4 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#0\u0026#34; 5 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#1\u0026#34; 除了这些 infrastructure，上面还有一个 名称 为org.springframework.aop.config.internalAutoProxyCreator 的 Bean。 这个 Bean 的实际类型是：org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator，它是一个 InstantiationAwareBeanPostProcessor，AbstractAdvisorAutoProxyCreator 类实现了下面这个方法：\n1 2 3 default Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) throws BeansException { return null; } 这个方法会在 Bean 的实例化前被调用，可以用于修改和创建 Bean 对象。 除此之外，AbstractAdvisorAutoProxyCreator 还实现了 BeanPostProcessor 接口的 postProcessAfterInitialization，在 Bean 对象执行完初始化方法后，会调用这个方法检测是否需要将其转化为代理对象。 AbstractAdvisorAutoProxyCreator 是 AOP 代理中非常关键的一个类，整个创建 AOP 代理的核心流程就是其执行的这两个方法。\n加载 Creator 上面提到，org.springframework.aop.config.internalAutoProxyCreator 是一个 BeanPostProcessor，那它具体创建并注册的位置就是： org.springframework.context.support#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) 调用这个方法的位置还是 ApplicationContext 的 refresh() 方法，具体的调用链路为： org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)\n具体就是将 BeanPostProcessor 加载到工厂中，方便后续的调用。 具体存放 BeanPostProcessor 的位置为：org.springframework.beans.factory.support.AbstractBeanFactory 的 beanPostProcessors 属性。\n加载 Advisors 在「XML 解析」部分，我们看到了 spring 为我们将 xml 中定义的 \u0026lt;acp:config /\u0026gt; 解析为具体的 Bean 定义。 并且在「加载 Creator」部分，spring 已经将 AOP 创建者类注册成了一个 InstantiationAwareBeanPostProcessor。 在将单例 Bean（原型 Bean 也可以被代理，本文只关注单例 Bean 的代理过程）加载代理之前，肯定是要将上面 \u0026lt;acp:config /\u0026gt; 中配置的 Bean 构建出来的。 而如果按照我们在 xml 中配置的方式，显然先构建的 Bean 将会是 userService。 所以在所有的 Bean 实例化之前，需要确保这些构建 AOP 的 infrastructure 被提前构建好，这就是 AbstractAdvisorAutoProxyCreator 在 Bean 初始化之前执行的逻辑。 我们依然从 refresh() 方法开始： org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt;org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons() 在预先实例化单例 Bean 的方法中，会对所有的 Bean 执行 getBean() 方法，getBean() 方法如果发现 Bean 没有被加载或者为原型 Bean，将会触发 Bean 的加载。\n=\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.getBean(String name) =\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(String name, @Nullable Class\u0026lt;T\u0026gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) Bean 的 createBean() 方法实际上是延迟调用的，后续在 spring 三级缓存中会具体讲解，这里我们可以视为直接调用了 createBean() 方法\n=\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) 这里就是具体执行 BeanPostProcessor 的位置：\n1 2 3 4 5 6 7 8 9 protected Object applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null; } 在这里会遍历所有的 BeanPostProcessor，然后调用其 postProcessBeforeInstantiation，上面的 AbstractAdvisorAutoProxyCreator 的该方法就是在这里调用的。\norg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // 如果有自定义的 TargetSource，则在这里创建代理对象 TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { if (StringUtils.hasLength(beanName)) { this.targetSourcedBeans.add(beanName); } Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } return null; } 在上面的 shouldSkip() 方法中，会尝试去获取所有的 Advisor，未创建的话，则会去尝试创建这些 Advisor。 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#shouldSkip(Class\u0026lt;?\u0026gt; beanClass, String beanName) =\u0026gt; org.springframework.aop.framework.autoproxy.AspectJAwareAdvisorAutoProxyCreator#findCandidateAdvisors() =\u0026gt; org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public List\u0026lt;Advisor\u0026gt; findAdvisorBeans() { // 获取 advisorNames String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } if (advisorNames.length == 0) { return new ArrayList\u0026lt;\u0026gt;(); } // 不断从 Factory 中去 getBean() List\u0026lt;Advisor\u0026gt; advisors = new ArrayList\u0026lt;\u0026gt;(); for (String name : advisorNames) { if (isEligibleBean(name)) { if (this.beanFactory.isCurrentlyInCreation(name)) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Skipping currently created advisor \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } } else { try { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } catch (BeanCreationException ex) { // ...... } } } } return advisors; } 最终在 BeanFactoryAdvisorRetrievalHelper 中，获取到了所有的 advisor。 对于没有指定 targetSource 的 Bean，AbstractAdvisorAutoProxyCreator 不会对其进行任何操作，而是只进行了 Advisor 的初始化。\n创建代理类 从 createBean() 方法开始，我们再来看一下代理类具体是怎么创建的： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) doCreateBean 就是实际上创建 Bean 的方法，当 Bean 被实例化完成之后，会执行 Bean 的初始化，当其初始化结束之后，就会执行 AbstractAdvisorAutoProxyCreator 实现的另一个重要方法，代理类的构建就是在这里完成的。\n=\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName) 这个方法会执行所有的 BeanPostProcessor 的 postProcessAfterInitialization() 方法，AbstractAdvisorAutoProxyCreator 中的这个方法就是在这里执行的：\n1 2 3 4 5 6 7 8 9 10 @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (this.earlyProxyReferences.remove(cacheKey) != bean) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } ","date":"2024-11-15T00:00:00Z","image":"http://localhost:1313/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image_hu6850457685914377867.png","permalink":"http://localhost:1313/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/","title":"Spring 代理类创建流程梳理"},{"content":"前言 AOP：意为面向切面编程，通过预编译的方式和运行期间动态代理实现程序功能功能的统一维护。\n既然要实现 AOP 就一定离不开代理，Spring 中使用两种代理方式：CgLib 动态代理和 AOP 动态代理，还通过引入 AspectJ 来简化切面编程。\nAOP 执行过程可以简单理解为对 切点(JointPoint) 执行 通知(Advice) 中定义的逻辑，这就引出两个核心的问题需要解决：\n通知在何处执行？ 如何判断当前执行的方法是否符合切点逻辑？ 动态代理可以让我们自由的在方法执行前后插入自己的逻辑，这就解决了通知在何处执行的问题；\n但是动态代理（无论是 JDKProxy 的 invoke() 还是 CgLib 的 interctpt()）都是在被代理的类中的任何方法执行前执行的，所以判断该方法是否需要执行切点逻辑需要我们来实现。\n图例\n上面展示的是一个代理类处理 AOP 的逻辑，其中 MethodInterceptor 是方法执行前的一个拦截器；MethodMatcher 是一个方法匹配器，通过它来判断接下来要执行的方法之前是否需要处理代理逻辑； 如果被代理的方法符合切点表达式，则按照顺序执行定义的代理逻辑，这样一个简单的 AOP 逻辑就打通了。\n案例 案例准备 1 2 3 4 5 6 7 8 9 10 11 public class UserService implements IUserService { public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 被代理的 UserService 类。\n定义方法匹配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MethodMatcherImpl implements MethodMatcher { private final PointcutExpression pointcutExpression; MethodMatcherImpl(String expression) { PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution(); pointcutExpression = parser.parsePointcutExpression(expression); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass) { return pointcutExpression.matchesMethodExecution(method).alwaysMatches(); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass, Object[] objects) { return false; } @Override public boolean isRuntime() { return false; } } 这是一个方法匹配类，用于检测输入的方法是否符合切点表达式 定义方法拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CgLibInterceptor implements MethodInterceptor { private final Object target; private final MethodMatcher methodMatcher; CgLibInterceptor(Object target, String expression) { this.methodMatcher = new MethodMatcherImpl(expression); this.target = target; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { if (methodMatcher.matches(method, target.getClass())) { System.out.println(\u0026#34;cglib代理：执行切面逻辑\u0026#34;); return methodProxy.invoke(target, objects); } return methodProxy.invoke(target, objects); } } 提供给 CgLib 的 CallBack 类，根据方法是否匹配切点表达式来决定是否执行切面逻辑。 创建代理类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ProxyTest { final static UserService target = new UserService(); public static void main(String[] args) throws IOException, InterruptedException { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserService.class); enhancer.setCallback(new CgLibInterceptor(target, \u0026#34;execution(* com.ryan.aop_test.service.impl.UserService.queryUserName(..))\u0026#34;)); UserService proxyService = (UserService) enhancer.create(); proxyService.queryUserName(\u0026#34;10001\u0026#34;); System.out.println(\u0026#34;======\u0026#34;); proxyService.queryUserId(\u0026#34;ryan\u0026#34;); } } 测试类，这里使用切点表达式匹配 UserService 类中的 queryUserName 方法 输出案例中，也只有这个方法会被代理 输出结果\n1 2 3 4 cglib代理 查询用户名称为：ryan ====== 查询用户ID为：10001 ","date":"2024-11-12T00:00:00Z","image":"http://localhost:1313/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/","title":"实现一个简单的 AOP 切面"},{"content":"什么是 AOP？ AOP（Aspect Oriented Programming），意为面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\nAOP是OOP的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n举一个简单的例子，如果我们想要在每次调用一个类中的方法之前输出一个日志,那如果我们要在这些方法之前加一个鉴权呢？同样，按照前面的方式，无非就是多 copy 一次嘛\n就这样，通过多重 copy 的方式，最终完成了这个业务，而这也就代表着，每次扩展新的方法，你都要去进行 n 次复制粘贴；每次要更改鉴权或者日志的逻辑，你都要去进行 n 次复制粘贴；每次。。。。。。\n听起来都让人非常头大，但如果我们将逻辑改成这样呢？\n现在来看看 AOP 能实现怎样的效果：\n这样，我们虽然每次都不用去复制代码了，但还是需要在我们需要的位置去调用这个接口，而调用这个代码的位置其实就是 切面。我们用具体的代码来看一下，下面实现了一个统一的接口 BeforeAdvice，然后在每个方法之前去调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface BeforeAdvice { void before(); } public class LoggingBeforeAdvice implements BeforeAdvice { @Override public void before() { System.out.println(\u0026#34;方法调用之前的日志\u0026#34;); } } public class MyService { private BeforeAdvice beforeAdvice = new LoggingBeforeAdvice(); public void myMethodA() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethod1A\u0026#34;); } public void myMethodB() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethodB\u0026#34;); } } AOP 核心概念 连接点（Join Point）：连接点是程序执行中的一个点，这个点可以是方法调用、方法执行、异常抛出等。在 Spring AOP 中，连接点主要是指方法的调用或执行。连接点是通知的实际应用点。\n切点（PointCut）：由于连接点可能很多（比如一个类中的所有方法），想要把所有连接点罗列出现显然有些困难；切点是一个定义，决定了 在哪些连接点上应用切面逻辑。 切点通过切点表达式（例如：execution(* com.example.service..(..))）来指定匹配的方法和类。切点表达式用于筛选连接点，使得通知只在特定的连接点上执行。\n通知（Advice）：通知是在切点处执行的代码。通知定义了具体的横切逻辑，决定了在方法执行的什么阶段（之前、之后、环绕等）插入横切逻辑。通知有五种类型，我们会在下一部分进行详细的了解；通知就是在 何时 执行 怎样 的逻辑。\n切面（Aspect）：切面是 AOP 的核心模块，它封装了跨越多个类的关注点，例如日志记录、事务管理或安全控制。切面通过通知（Advice）和切点（Pointcut）来定义在何时、何地应用这些关注点；可以将切面看作是切点（Pointcut）和通知（Advice）的组合。 切面定义了在何处（切点）以及何时（通知）应用横切逻辑。\n五种通知类型 前置通知（Before Advice） 在目标方法执行之前执行的通知。可以用来执行日志记录、安全检查等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @Before(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void beforeAdvice() { System.out.println(\u0026#34;前置通知：方法调用之前执行\u0026#34;); } } 后置通知（After Advice） 在目标方法执行之后执行的通知，无论方法是成功返回还是抛出异常。常用于清理资源等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @After(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void afterAdvice() { System.out.println(\u0026#34;后置通知：方法调用之后执行\u0026#34;); } } 返回后通知（After Returning Advice） 在目标方法成功返回结果之后执行的通知。可以用来记录返回值或对返回值进行处理。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterReturning(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, returning = \u0026#34;result\u0026#34;) public void afterReturningAdvice(Object result) { System.out.println(\u0026#34;返回后通知：方法返回值为 \u0026#34; + result); } } 抛出异常后通知（After Throwing Advice） 在目标方法抛出异常后执行的通知。可以用来记录异常信息或执行异常处理逻辑。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, throwing = \u0026#34;exception\u0026#34;) public void afterThrowingAdvice(Exception exception) { System.out.println(\u0026#34;抛出异常后通知：异常为 \u0026#34; + exception.getMessage()); } } 环绕通知（Around Advice） 环绕通知在目标方法执行的前后都执行，可以完全控制目标方法的执行，包括决定是否执行目标方法，以及在目标方法执行前后添加自定义逻辑。环绕通知最为强大和灵活。\n1 2 3 4 5 6 7 8 9 10 11 @Aspect @Component public class LoggingAspect { @Around(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;环绕通知：方法调用之前\u0026#34;); Object result = joinPoint.proceed(); // 执行目标方法 System.out.println(\u0026#34;环绕通知：方法调用之后\u0026#34;); return result; } } 这五种通知类型的执行顺序是这样的： 前置通知（Before Advice） 环绕通知（Around Advice）的前半部分 目标方法执行 环绕通知（Around Advice）的后半部分 返回后通知（After Returning Advice）（如果目标方法成功返回） 抛出异常后通知（After Throwing Advice）（如果目标方法抛出异常） 后置通知（After Advice）\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","title":"AOP 核心概念"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"}]