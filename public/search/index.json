[{"content":"关于\n沿着上节的流程，详细的来看看 wrapIfNecessary() 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { if (StringUtils.hasLength(beanName) \u0026amp;\u0026amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // 如果该类的 Advisor 不为空，创建代理类 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } 不生成代理类的情况 1 2 3 4 5 6 7 8 9 10 if (StringUtils.hasLength(beanName) \u0026amp;\u0026amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } 以下的四种情况将不会生成代理类：\nBeanName 不为空且在 targetSourcedBeans 集合中，直接返回原始 bean。 AdvisedBeans 缓存中存在 cacheKey 且值为 false，直接返回原始 bean。 Bean 属于基础设施类或满足跳过条件，将 cacheKey 标记为 false 并返回原始 bean。 没有与 Bean 匹配的 Advisor 获取适配类的 Advisors 1 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean(Class\u0026lt;?\u0026gt; beanClass, String beanName, @Nullable TargetSource targetSource)\n1 2 3 4 5 6 7 8 9 @Override @Nullable protected Object[] getAdvicesAndAdvisorsForBean(Class\u0026lt;?\u0026gt; beanClass, String beanName, @Nullable TargetSource targetSource) { List\u0026lt;Advisor\u0026gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) { return DO_NOT_PROXY; } return advisors.toArray(); } org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors(Class\u0026lt;?\u0026gt; beanClass, String beanName)\n1 2 3 4 5 6 7 8 9 protected List\u0026lt;Advisor\u0026gt; findEligibleAdvisors(Class\u0026lt;?\u0026gt; beanClass, String beanName) { List\u0026lt;Advisor\u0026gt; candidateAdvisors = findCandidateAdvisors(); List\u0026lt;Advisor\u0026gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors; } 首先调用 findCandidateAdvisors 拿到所有的候选者 Advisor，再调用 findAdvisorsThatCanApply 选出适配该 Bean 的 Advisor。\n最终会调用到这个方法： org.springframework.aop.support.AopUtils#findAdvisorsThatCanApply(List\u0026lt;Advisor\u0026gt; candidateAdvisors, Class\u0026lt;?\u0026gt; clazz)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static List\u0026lt;Advisor\u0026gt; findAdvisorsThatCanApply(List\u0026lt;Advisor\u0026gt; candidateAdvisors, Class\u0026lt;?\u0026gt; clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List\u0026lt;Advisor\u0026gt; eligibleAdvisors = new ArrayList\u0026lt;\u0026gt;(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor \u0026amp;\u0026amp; canApply(candidate, clazz)) { eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors; } 这个方法 findAdvisorsThatCanApply 用于过滤和筛选出可以应用于特定目标类 clazz 的增强器（Advisor），即 找出与该类匹配的 Advisor 列表。 首先遍历 candidateAdvisors 列表，筛选出所有的 IntroductionAdvisor。 对于每个 IntroductionAdvisor，调用 canApply(candidate, clazz) 方法判断它是否适用于目标类 clazz。 如果适用，就将它添加到 eligibleAdvisors 列表中。 再次遍历 candidateAdvisors 列表，排除 IntroductionAdvisor，只处理普通的 Advisor。 对于每个普通的 Advisor，调用 canApply(candidate, clazz, hasIntroductions) 方法检查它是否适用于目标类 clazz。 如果适用，将其添加到 eligibleAdvisors 列表中。\n创建代理类 1 2 3 4 5 6 7 if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } 如果 specificInterceptors 不为 null 就会去创建代理；\norg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#createProxy(Class\u0026lt;?\u0026gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 protected Object createProxy(Class\u0026lt;?\u0026gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) { if (this.beanFactory instanceof ConfigurableListableBeanFactory) { AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); } ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); if (proxyFactory.isProxyTargetClass()) { // Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios) if (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) { // Must allow for introductions; can\u0026#39;t just set interfaces to the proxy\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : beanClass.getInterfaces()) { proxyFactory.addInterface(ifc); } } } else { // No proxyTargetClass flag enforced, let\u0026#39;s apply our default checks... if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // Use original ClassLoader if bean class not locally loaded in overriding class loader ClassLoader classLoader = getProxyClassLoader(); if (classLoader instanceof SmartClassLoader \u0026amp;\u0026amp; classLoader != beanClass.getClassLoader()) { classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader(); } return proxyFactory.getProxy(classLoader); } 该方法的返回值为：proxyFactory.getProxy(classLoader);，即调用 proxyFactory 的创建代理方法。\n代理工厂的初始化配置 整个方法其实就是对代理工厂的一个构建，在调用 proxyFactory.copyFrom(this); ，会将 Creator 的配置复制到代理工厂中： org.springframework.aop.framework.ProxyConfig#copyFrom(ProxyConfig other)\n1 2 3 4 5 6 7 8 public void copyFrom(ProxyConfig other) { Assert.notNull(other, \u0026#34;Other ProxyConfig object must not be null\u0026#34;); this.proxyTargetClass = other.proxyTargetClass; this.optimize = other.optimize; this.exposeProxy = other.exposeProxy; this.frozen = other.frozen; this.opaque = other.opaque; } proxyTargetSource：设置是否直接代理目标类，而不是仅代理特定的接口。默认值为 \u0026ldquo;false\u0026rdquo;。\n将其设置为 \u0026ldquo;true\u0026rdquo; 时，会强制对 TargetSource 所暴露的目标类进行代理。 如果目标类是一个接口，则会为该接口创建一个 JDK 代理。 如果目标类是一个普通的类，则会为该类创建一个 CGLIB 代理。 optimize：设置代理是否应执行“积极优化”。\n“积极优化”的具体含义因代理类型而异，但通常会涉及某种权衡，默认值为 \u0026ldquo;false\u0026rdquo;。 在 Spring 当前的代理选项中，此标志实际上会强制使用 CGLIB 代理，但不会执行任何类验证检查（如对 final 方法的检查等）。 opaque：设置由此配置创建的代理是否应该禁止被强制转换为 {@link Advised} 以查询代理状态。\n默认值为 \u0026ldquo;false\u0026rdquo;，这意味着任何 AOP 代理都可以被强制转换为 {@link Advised}。 frozen：决定代理的配置是否可以在运行时修改。\n默认情况下，配置是可变的，调用者可以通过将代理转换为 Advised 接口来修改通知链或其他配置。 当其设置为 true 的时候： 配置被锁定，不能再动态更改通知或切面配置。 增强系统的稳定性和性能，因为代理不需要支持动态修改。 根据是否代理目标类执行不同的操作 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (proxyFactory.isProxyTargetClass()) { // Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios) if (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) { // Must allow for introductions; can\u0026#39;t just set interfaces to the proxy\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : beanClass.getInterfaces()) { proxyFactory.addInterface(ifc); } } } else { // No proxyTargetClass flag enforced, let\u0026#39;s apply our default checks... if (shouldProxyTargetClass(beanClass, beanName)) { proxyFactory.setProxyTargetClass(true); } else { evaluateProxyInterfaces(beanClass, proxyFactory); } } 上面我们提到，proxyTargetSource：设置是否直接代理目标类，而不是仅代理特定的接口。默认值为 \u0026ldquo;false\u0026rdquo;。 如果为 true 的话，对 JDK 代理类和 lambda 接口的实现类做一些特殊的处理，也就是保存接口的类型。 如果设置为 false 的话，执行默认的操作 首先检查 Bean 定义中是否明确制定了需要代理类而不是接口，如果是的话，将 proxyTargetSource 设置为 true。 反之调用 evaluateProxyInterfaces，评估 Bean 是否有实现的接口，我们说的如果 代理类没有实现接口，使用 CgLib 代理，反之，使用 JDK 代理正是这个方法的原因。\n全限定名：org.springframework.aop.framework.ProxyProcessorSupport#evaluateProxyInterfaces(Class\u0026lt;?\u0026gt; beanClass, ProxyFactory proxyFactory) 方法注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Check the interfaces on the given bean class and apply them to the {@link ProxyFactory}, * if appropriate. * \u0026lt;p\u0026gt;Calls {@link #isConfigurationCallbackInterface} and {@link #isInternalLanguageInterface} * to filter for reasonable proxy interfaces, falling back to a target-class proxy otherwise. * @param beanClass the class of the bean * @param proxyFactory the ProxyFactory for the bean */ /** * 检查给定 Bean 类上的接口，并在合适的情况下将这些接口应用到 {@link ProxyFactory}。 * * \u0026lt;p\u0026gt;会调用 {@link #isConfigurationCallbackInterface} 和 {@link #isInternalLanguageInterface} * 方法来过滤出合理的代理接口。如果没有找到合理的接口，则会退回到基于目标类（target-class）的代理。 * * @param beanClass Bean 的类 * @param proxyFactory 用于创建代理的 {@link ProxyFactory} */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 protected void evaluateProxyInterfaces(Class\u0026lt;?\u0026gt; beanClass, ProxyFactory proxyFactory) { Class\u0026lt;?\u0026gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader()); boolean hasReasonableProxyInterface = false; for (Class\u0026lt;?\u0026gt; ifc : targetInterfaces) { if (!isConfigurationCallbackInterface(ifc) \u0026amp;\u0026amp; !isInternalLanguageInterface(ifc) \u0026amp;\u0026amp; ifc.getMethods().length \u0026gt; 0) { hasReasonableProxyInterface = true; break; } } if (hasReasonableProxyInterface) { // Must allow for introductions; can\u0026#39;t just set interfaces to the target\u0026#39;s interfaces only. for (Class\u0026lt;?\u0026gt; ifc : targetInterfaces) { proxyFactory.addInterface(ifc); } } else { proxyFactory.setProxyTargetClass(true); } } 这个方法的作用是从目标类（beanClass）中提取需要代理的接口，并将它们添加到代理工厂（ProxyFactory）中，而如果没有找到合适的接口（即所有接口都被过滤掉），则会使用目标类进行代理（即启用 CGLIB 动态代理）。 使用 isConfigurationCallbackInterface 和 isInternalLanguageInterface 方法对接口进行筛选，确保只代理合理的接口。\n合理的接口通常是用户定义的接口，而非 Spring 内部使用的回调接口或与语言机制相关的内部接口。 这两个方法将这些接口排除在外： 1 2 3 4 5 6 7 8 9 protected boolean isConfigurationCallbackInterface(Class\u0026lt;?\u0026gt; ifc) { return (InitializingBean.class == ifc || DisposableBean.class == ifc || Closeable.class == ifc || AutoCloseable.class == ifc || ObjectUtils.containsElement(ifc.getInterfaces(), Aware.class)); } protected boolean isInternalLanguageInterface(Class\u0026lt;?\u0026gt; ifc) { return (ifc.getName().equals(\u0026#34;groovy.lang.GroovyObject\u0026#34;) || ifc.getName().endsWith(\u0026#34;.cglib.proxy.Factory\u0026#34;) || ifc.getName().endsWith(\u0026#34;.bytebuddy.MockAccess\u0026#34;)); } 如果筛选后没有适合的接口，则会回退到基于目标类的代理方式（ 触发 CGLIB 动态代理 ）。\n填充代理工厂的其他属性 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); proxyFactory.addAdvisors(advisors); proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) { proxyFactory.setPreFiltered(true); } // Use original ClassLoader if bean class not locally loaded in overriding class loader ClassLoader classLoader = getProxyClassLoader(); if (classLoader instanceof SmartClassLoader \u0026amp;\u0026amp; classLoader != beanClass.getClassLoader()) { classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader(); } 获取并构建一个 Advisor 列表，这个 specificInterceptors 是从 wrapIfNecessory中传递下来的，然后将这些 Advisor 添加到代理工厂。 Spring 使用 SmartClassLoader 检测目标类的类加载器和代理类的类加载器是否一致： 如果代理类的类加载器与目标类不一致，可能会导致类加载问题，因此 Spring 会尝试调整使用的类加载器。\n正式开始创建代理类 1 return proxyFactory.getProxy(classLoader); 其最终会调用到这个方法：\n全限定名：org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy(AdvisedSupport config) 接口定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Create an {@link AopProxy} for the given AOP configuration. * @param config the AOP configuration in the form of an * AdvisedSupport object * @return the corresponding AOP proxy * @throws AopConfigException if the configuration is invalid */ /** * 为给定的 AOP 配置创建一个 {@link AopProxy} 实例。 * * @param config 以 {@link AdvisedSupport} 对象形式表示的 AOP 配置信息 * @return 对应的 AOP 代理 * @throws AopConfigException 如果配置无效，则抛出此异常 / 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException { if (!NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) { Class\u0026lt;?\u0026gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\u0026#34;TargetSource cannot determine target class: \u0026#34; + \u0026#34;Either an interface or a target is required for proxy creation.\u0026#34;); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } else { return new JdkDynamicAopProxy(config); } } 传入的参数 AdvisedSupport 实际上就是我们上面构建的代理工厂，其实现了 AdvisedSupport 接口。 我们再来梳理一下这个配置中对一些值：\nisOptimize：默认 false，不进行智能代理优化 isProxyTargetClass：类或者Creator 指定需要代理的是目标类 或 类没有实现任何可用接口 时为 true，其他时候为 false 创建 CgLib 代理类 对应源码的这一部分：\n1 2 3 4 5 6 7 8 9 10 11 12 if (!NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) { Class\u0026lt;?\u0026gt; targetClass = config.getTargetClass(); if (targetClass == null) { throw new AopConfigException(\u0026#34;TargetSource cannot determine target class: \u0026#34; + \u0026#34;Either an interface or a target is required for proxy creation.\u0026#34;); } if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) { return new JdkDynamicAopProxy(config); } return new ObjenesisCglibAopProxy(config); } !NativeDetector.inNativeImage() 用于检测当前环境能否使用 CgLib 代理，如果允许的话，下面的条件符合任意一条都会出发 CgLib 代理：\nisOptimize 智能代理优化 isProxyTargetClass 需要代理目标类 hasNoUserSuppliedProxyInterfaces，检测接口，如果发现用户没有提供任何自定义接口，Spring 可能会选择使用 CGLIB 代理。 还有一些特殊的情况，创建的是 JDK 代理类，这个放到下面去说。 创建 JDK 代理类 当下面的条件不符合\n1 !NativeDetector.inNativeImage() \u0026amp;\u0026amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) 或者代理的类是一个接口、代理的类已经是一个 JDK 代理类、代理的类是一个 lambda 表达式的实现类\n1 targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass) 的时候，会创建 JDK 代理类。\n","date":"2024-11-17T00:00:00Z","image":"http://localhost:60831/p/spring-aop-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/image_hu15123054864233634991.png","permalink":"http://localhost:60831/p/spring-aop-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/","title":"Spring AOP 代理类创建方法解析"},{"content":"这部分我们来具体的看一下 Spring AOP 实现中，代理类究竟是什么时候被构建的。\n案例准备 maven pom 文件 spring.version：5.3.22 java.version：1.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!-- Spring核心库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring IoC容器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring上下文支持，提供了BeanFactory的扩展 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Service 接口与实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public interface IUserService { void queryUserName(String uId); void queryUserId(String name); } public class UserService implements IUserService { @Override public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } @Override public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 通知类 1 2 3 4 5 6 7 8 9 10 11 public class LogAdvices { public void before() { System.out.println(\u0026#34;before\u0026#34;); } public void after() { System.out.println(\u0026#34;after\u0026#34;); } } 为了演示方便，本文所有的 Bean 都会通过配置文件来配置。 Main 方法 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main(String[] args) { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); IUserService service = applicationContext.getBean(\u0026#34;userService\u0026#34;, IUserService.class); System.out.println(service.getClass()); service.queryUserName(\u0026#34;10001\u0026#34;); } } spring xml 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.ryan.aop_test.service.impl.UserService\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;logAspect\u0026#34; class=\u0026#34;com.ryan.aop_test.LogAdvices\u0026#34; /\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point1\u0026#34; expression=\u0026#34;execution(* com.ryan.aop_test.service.*.*(..))\u0026#34; /\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;logAspect\u0026#34;\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34; /\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; 关于 spring 通过 xml 配置 aop 的具体内容可以参照官网：\n文档地址：https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop-schema 需要注意，这种方式使用的是 Spring 的自动代理机制，如果有类似 BeanNameAutoProxyCreator 或类似的类使用了显示的代理，会导致其中的某一项失效。 建议的使用方式是仅使用\u0026lt;aop:config\u0026gt;样式或仅使用AutoProxyCreator样式，并且切勿混合使用它们。\n执行结果 先来看一下上面的 Main 方法执行后的效果：\n1 2 3 4 class com.sun.proxy.$Proxy3 before 查询用户名称为：ryan after 可以看到，我们获取到的类是一个代理类，并且代理方法已经执行成功了。\n源码分析 XML 解析 当执行下面这条语句之后：\n1 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;spring-aop.xml\u0026#34;); 会执行 ClassPathXmlApplicationContext 的 refresh 方法： org.springframework.context.support.AbstractApplicationContext#refresh()\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(\u0026#34;spring.context.refresh\u0026#34;); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // ...... } 其中 obtainFreshBeanFactory 会执行 Bean 工厂的初始化，其中最重要的部分就是将 XML 配置文件中的 Bean 定义（Bean Definition）加载到 Bean 工厂中。\n1 2 3 4 5 6 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory() =\u0026gt; org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 上面的是从 `refresh()` 方法到具体加载 Bean Definition 方法的调用链路。 org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException { // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context\u0026#39;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader); } 具体解析 XML 和加载 Bean Definition 的方法 关于具体是如何解析 XML 的，这里就不细看了，我们直接看一下从我们的 XML 配置文件中可以解析到什么 配置文件：[[🗺️【spring-aop】Spring 代理类创建流程梳理#spring xml 配置文件]]\n1 2 3 4 5 6 7 beanDefinitionNames = {ArrayList@1626} size = 6 0 = \u0026#34;userService\u0026#34; 1 = \u0026#34;logAspect\u0026#34; 2 = \u0026#34;org.springframework.aop.config.internalAutoProxyCreator\u0026#34; 3 = \u0026#34;point1\u0026#34; 4 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#0\u0026#34; 5 = \u0026#34;org.springframework.aop.aspectj.AspectJPointcutAdvisor#1\u0026#34; 除了这些 infrastructure，上面还有一个 名称 为org.springframework.aop.config.internalAutoProxyCreator 的 Bean。 这个 Bean 的实际类型是：org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator，它是一个 InstantiationAwareBeanPostProcessor，AbstractAdvisorAutoProxyCreator 类实现了下面这个方法：\n1 2 3 default Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) throws BeansException { return null; } 这个方法会在 Bean 的实例化前被调用，可以用于修改和创建 Bean 对象。 除此之外，AbstractAdvisorAutoProxyCreator 还实现了 BeanPostProcessor 接口的 postProcessAfterInitialization，在 Bean 对象执行完初始化方法后，会调用这个方法检测是否需要将其转化为代理对象。 AbstractAdvisorAutoProxyCreator 是 AOP 代理中非常关键的一个类，整个创建 AOP 代理的核心流程就是其执行的这两个方法。\n加载 Creator 上面提到，org.springframework.aop.config.internalAutoProxyCreator 是一个 BeanPostProcessor，那它具体创建并注册的位置就是： org.springframework.context.support#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) 调用这个方法的位置还是 ApplicationContext 的 refresh() 方法，具体的调用链路为：\n1 2 3 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) 具体就是将 BeanPostProcessor 加载到工厂中，方便后续的调用。 具体存放 BeanPostProcessor 的位置为：org.springframework.beans.factory.support.AbstractBeanFactory 的 beanPostProcessors 属性。\n加载 Advisors 在「XML 解析」部分，我们看到了 spring 为我们将 xml 中定义的 \u0026lt;acp:config /\u0026gt; 解析为具体的 Bean 定义。 并且在「加载 Creator」部分，spring 已经将 AOP 创建者类注册成了一个 InstantiationAwareBeanPostProcessor。 在将单例 Bean（原型 Bean 也可以被代理，本文只关注单例 Bean 的代理过程）加载代理之前，肯定是要将上面 \u0026lt;acp:config /\u0026gt; 中配置的 Bean 构建出来的。 而如果按照我们在 xml 中配置的方式，显然先构建的 Bean 将会是 userService。 所以在所有的 Bean 实例化之前，需要确保这些构建 AOP 的 infrastructure 被提前构建好，这就是 AbstractAdvisorAutoProxyCreator 在 Bean 初始化之前执行的逻辑。 我们依然从 refresh() 方法开始：\n1 2 3 4 5 6 7 8 9 10 11 12 org.springframework.context.support.AbstractApplicationContext#refresh() =\u0026gt; org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) =\u0026gt; org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons() 在预先实例化单例 Bean 的方法中，会对所有的 Bean 执行 `getBean()` 方法，`getBean()` 方法如果发现 Bean 没有被加载或者为原型 Bean，将会触发 Bean 的加载。 =\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.getBean(String name) =\u0026gt; org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(String name, @Nullable Class\u0026lt;T\u0026gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) Bean 的 `createBean()` 方法实际上是延迟调用的，后续在 spring 三级缓存中会具体讲解，这里我们可以视为直接调用了 `createBean() 方法 =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) 这里就是具体执行 BeanPostProcessor 的位置：\n1 2 3 4 5 6 7 8 9 protected Object applyBeanPostProcessorsBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) { Object result = bp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) { return result; } } return null; } 在这里会遍历所有的 BeanPostProcessor，然后调用其 postProcessBeforeInstantiation，上面的 AbstractAdvisorAutoProxyCreator 的该方法就是在这里调用的。\norg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public Object postProcessBeforeInstantiation(Class\u0026lt;?\u0026gt; beanClass, String beanName) { Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } // 如果有自定义的 TargetSource，则在这里创建代理对象 TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { if (StringUtils.hasLength(beanName)) { this.targetSourcedBeans.add(beanName); } Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } return null; } 在上面的 shouldSkip() 方法中，会尝试去获取所有的 Advisor，未创建的话，则会去尝试创建这些 Advisor。\n1 2 3 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#shouldSkip(Class\u0026lt;?\u0026gt; beanClass, String beanName) =\u0026gt; org.springframework.aop.framework.autoproxy.AspectJAwareAdvisorAutoProxyCreator#findCandidateAdvisors() =\u0026gt; org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public List\u0026lt;Advisor\u0026gt; findAdvisorBeans() { // 获取 advisorNames String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the auto-proxy creator apply to them! advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } if (advisorNames.length == 0) { return new ArrayList\u0026lt;\u0026gt;(); } // 不断从 Factory 中去 getBean() List\u0026lt;Advisor\u0026gt; advisors = new ArrayList\u0026lt;\u0026gt;(); for (String name : advisorNames) { if (isEligibleBean(name)) { if (this.beanFactory.isCurrentlyInCreation(name)) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Skipping currently created advisor \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } } else { try { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } catch (BeanCreationException ex) { // ...... } } } } return advisors; } 最终在 BeanFactoryAdvisorRetrievalHelper 中，获取到了所有的 advisor。 对于没有指定 targetSource 的 Bean，AbstractAdvisorAutoProxyCreator 不会对其进行任何操作，而是只进行了 Advisor 的初始化。\n创建代理类 从 createBean() 方法开始，我们再来看一下代理类具体是怎么创建的：\n1 2 3 4 5 6 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) =\u0026gt; org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) doCreateBean 就是实际上创建 Bean 的方法，当 Bean 被实例化完成之后，会执行 Bean 的初始化，当其初始化结束之后，就会执行 AbstractAdvisorAutoProxyCreator 实现的另一个重要方法，代理类的构建就是在这里完成的。 =\u0026gt; `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) =\u0026gt; `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName) 这个方法会执行所有的 BeanPostProcessor 的 postProcessAfterInitialization() 方法，AbstractAdvisorAutoProxyCreator 中的这个方法就是在这里执行的：\n1 2 3 4 5 6 7 8 9 10 @Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (this.earlyProxyReferences.remove(cacheKey) != bean) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean; } ","date":"2024-11-15T00:00:00Z","image":"http://localhost:60831/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/image_hu6850457685914377867.png","permalink":"http://localhost:60831/p/spring-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/","title":"Spring 代理类创建流程梳理"},{"content":"前言 AOP：意为面向切面编程，通过预编译的方式和运行期间动态代理实现程序功能功能的统一维护。\n既然要实现 AOP 就一定离不开代理，Spring 中使用两种代理方式：CgLib 动态代理和 AOP 动态代理，还通过引入 AspectJ 来简化切面编程。\nAOP 执行过程可以简单理解为对 切点(JointPoint) 执行 通知(Advice) 中定义的逻辑，这就引出两个核心的问题需要解决：\n通知在何处执行？ 如何判断当前执行的方法是否符合切点逻辑？ 动态代理可以让我们自由的在方法执行前后插入自己的逻辑，这就解决了通知在何处执行的问题；\n但是动态代理（无论是 JDKProxy 的 invoke() 还是 CgLib 的 interctpt()）都是在被代理的类中的任何方法执行前执行的，所以判断该方法是否需要执行切点逻辑需要我们来实现。\n图例\n上面展示的是一个代理类处理 AOP 的逻辑，其中 MethodInterceptor 是方法执行前的一个拦截器；MethodMatcher 是一个方法匹配器，通过它来判断接下来要执行的方法之前是否需要处理代理逻辑； 如果被代理的方法符合切点表达式，则按照顺序执行定义的代理逻辑，这样一个简单的 AOP 逻辑就打通了。\n案例 案例准备 1 2 3 4 5 6 7 8 9 10 11 public class UserService implements IUserService { public void queryUserName(String uId) { System.out.println(\u0026#34;查询用户名称为：ryan\u0026#34;); } public void queryUserId(String name) { System.out.println(\u0026#34;查询用户ID为：10001\u0026#34;); } } 被代理的 UserService 类。\n定义方法匹配器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MethodMatcherImpl implements MethodMatcher { private final PointcutExpression pointcutExpression; MethodMatcherImpl(String expression) { PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution(); pointcutExpression = parser.parsePointcutExpression(expression); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass) { return pointcutExpression.matchesMethodExecution(method).alwaysMatches(); } @Override public boolean matches(Method method, Class\u0026lt;?\u0026gt; aClass, Object[] objects) { return false; } @Override public boolean isRuntime() { return false; } } 这是一个方法匹配类，用于检测输入的方法是否符合切点表达式 定义方法拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CgLibInterceptor implements MethodInterceptor { private final Object target; private final MethodMatcher methodMatcher; CgLibInterceptor(Object target, String expression) { this.methodMatcher = new MethodMatcherImpl(expression); this.target = target; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { if (methodMatcher.matches(method, target.getClass())) { System.out.println(\u0026#34;cglib代理：执行切面逻辑\u0026#34;); return methodProxy.invoke(target, objects); } return methodProxy.invoke(target, objects); } } 提供给 CgLib 的 CallBack 类，根据方法是否匹配切点表达式来决定是否执行切面逻辑。 创建代理类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class ProxyTest { final static UserService target = new UserService(); public static void main(String[] args) throws IOException, InterruptedException { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserService.class); enhancer.setCallback(new CgLibInterceptor(target, \u0026#34;execution(* com.ryan.aop_test.service.impl.UserService.queryUserName(..))\u0026#34;)); UserService proxyService = (UserService) enhancer.create(); proxyService.queryUserName(\u0026#34;10001\u0026#34;); System.out.println(\u0026#34;======\u0026#34;); proxyService.queryUserId(\u0026#34;ryan\u0026#34;); } } 测试类，这里使用切点表达式匹配 UserService 类中的 queryUserName 方法 输出案例中，也只有这个方法会被代理 输出结果\n1 2 3 4 cglib代理 查询用户名称为：ryan ====== 查询用户ID为：10001 ","date":"2024-11-12T00:00:00Z","image":"http://localhost:60831/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:60831/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-aop-%E5%88%87%E9%9D%A2/","title":"实现一个简单的 AOP 切面"},{"content":"什么是 AOP？ AOP（Aspect Oriented Programming），意为面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\nAOP是OOP的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n举一个简单的例子，如果我们想要在每次调用一个类中的方法之前输出一个日志,那如果我们要在这些方法之前加一个鉴权呢？同样，按照前面的方式，无非就是多 copy 一次嘛\n就这样，通过多重 copy 的方式，最终完成了这个业务，而这也就代表着，每次扩展新的方法，你都要去进行 n 次复制粘贴；每次要更改鉴权或者日志的逻辑，你都要去进行 n 次复制粘贴；每次。。。。。。\n听起来都让人非常头大，但如果我们将逻辑改成这样呢？\n现在来看看 AOP 能实现怎样的效果：\n这样，我们虽然每次都不用去复制代码了，但还是需要在我们需要的位置去调用这个接口，而调用这个代码的位置其实就是 切面。我们用具体的代码来看一下，下面实现了一个统一的接口 BeforeAdvice，然后在每个方法之前去调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface BeforeAdvice { void before(); } public class LoggingBeforeAdvice implements BeforeAdvice { @Override public void before() { System.out.println(\u0026#34;方法调用之前的日志\u0026#34;); } } public class MyService { private BeforeAdvice beforeAdvice = new LoggingBeforeAdvice(); public void myMethodA() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethod1A\u0026#34;); } public void myMethodB() { beforeAdvice.before(); // 业务逻辑 System.out.println(\u0026#34;执行 myMethodB\u0026#34;); } } AOP 核心概念 连接点（Join Point）：连接点是程序执行中的一个点，这个点可以是方法调用、方法执行、异常抛出等。在 Spring AOP 中，连接点主要是指方法的调用或执行。连接点是通知的实际应用点。\n切点（PointCut）：由于连接点可能很多（比如一个类中的所有方法），想要把所有连接点罗列出现显然有些困难；切点是一个定义，决定了 在哪些连接点上应用切面逻辑。 切点通过切点表达式（例如：execution(* com.example.service..(..))）来指定匹配的方法和类。切点表达式用于筛选连接点，使得通知只在特定的连接点上执行。\n通知（Advice）：通知是在切点处执行的代码。通知定义了具体的横切逻辑，决定了在方法执行的什么阶段（之前、之后、环绕等）插入横切逻辑。通知有五种类型，我们会在下一部分进行详细的了解；通知就是在 何时 执行 怎样 的逻辑。\n切面（Aspect）：切面是 AOP 的核心模块，它封装了跨越多个类的关注点，例如日志记录、事务管理或安全控制。切面通过通知（Advice）和切点（Pointcut）来定义在何时、何地应用这些关注点；可以将切面看作是切点（Pointcut）和通知（Advice）的组合。 切面定义了在何处（切点）以及何时（通知）应用横切逻辑。\n五种通知类型 前置通知（Before Advice） 在目标方法执行之前执行的通知。可以用来执行日志记录、安全检查等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @Before(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void beforeAdvice() { System.out.println(\u0026#34;前置通知：方法调用之前执行\u0026#34;); } } 后置通知（After Advice） 在目标方法执行之后执行的通知，无论方法是成功返回还是抛出异常。常用于清理资源等。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @After(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void afterAdvice() { System.out.println(\u0026#34;后置通知：方法调用之后执行\u0026#34;); } } 返回后通知（After Returning Advice） 在目标方法成功返回结果之后执行的通知。可以用来记录返回值或对返回值进行处理。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterReturning(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, returning = \u0026#34;result\u0026#34;) public void afterReturningAdvice(Object result) { System.out.println(\u0026#34;返回后通知：方法返回值为 \u0026#34; + result); } } 抛出异常后通知（After Throwing Advice） 在目标方法抛出异常后执行的通知。可以用来记录异常信息或执行异常处理逻辑。\n1 2 3 4 5 6 7 8 @Aspect @Component public class LoggingAspect { @AfterThrowing(pointcut = \u0026#34;execution(* com.example.service.*.*(..))\u0026#34;, throwing = \u0026#34;exception\u0026#34;) public void afterThrowingAdvice(Exception exception) { System.out.println(\u0026#34;抛出异常后通知：异常为 \u0026#34; + exception.getMessage()); } } 环绕通知（Around Advice） 环绕通知在目标方法执行的前后都执行，可以完全控制目标方法的执行，包括决定是否执行目标方法，以及在目标方法执行前后添加自定义逻辑。环绕通知最为强大和灵活。\n1 2 3 4 5 6 7 8 9 10 11 @Aspect @Component public class LoggingAspect { @Around(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;环绕通知：方法调用之前\u0026#34;); Object result = joinPoint.proceed(); // 执行目标方法 System.out.println(\u0026#34;环绕通知：方法调用之后\u0026#34;); return result; } } 这五种通知类型的执行顺序是这样的： 前置通知（Before Advice） 环绕通知（Around Advice）的前半部分 目标方法执行 环绕通知（Around Advice）的后半部分 返回后通知（After Returning Advice）（如果目标方法成功返回） 抛出异常后通知（After Throwing Advice）（如果目标方法抛出异常） 后置通知（After Advice）\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:60831/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:60831/p/aop-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","title":"AOP 核心概念"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:60831/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:60831/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:60831/p/math-typesetting/","title":"Math Typesetting"}]